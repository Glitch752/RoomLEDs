use std::{collections::HashSet, io::Write, path::PathBuf, sync::{LazyLock, Mutex}};

use crate::{Error, Reflect};

mod recursive_export;

pub(crate) static EXPORTED_TYPES: LazyLock<Mutex<HashSet<String>>> = LazyLock::new(|| { Mutex::new(HashSet::new()) });
pub(crate) const FILE_HEADER: &str = "/**\n * This file was generated by this project's reflection framework.\n * Don't edit it manually. \n */";

/// Gets the export path for types.
/// All types are currently exported into the same file.
fn get_export_file_path() -> PathBuf {
    PathBuf::from("./bindings/index.ts")
}

pub(crate) fn export<T: Reflect + ?Sized + 'static>() -> Result<(), Error> {
    let mut exported_types = EXPORTED_TYPES.lock().unwrap();

    // If this type has already been exported, return early
    let type_name = std::any::type_name::<T>();
    if exported_types.contains(type_name) {
        return Ok(());
    }

    let buffer = export_to_string::<T>()?;
    let path = get_export_file_path();
    
    // If no types have been exported yet, delete the file if it exists
    if exported_types.is_empty() {
        if path.exists() {
            std::fs::remove_file(&path)?;
        }
        // Create the file and write the header
        std::fs::write(&path, FILE_HEADER)?;
    }

    // Append the type to the file
    let mut file = std::fs::OpenOptions::new().append(true).open(path)?;
    file.write_all(buffer.as_bytes())?;

    // Add the type to the set of exported types
    exported_types.insert(std::any::type_name::<T>().to_string());

    Ok(())
}

pub(crate) fn export_to_string<T: Reflect + ?Sized + 'static>() -> Result<String, Error> {
    let mut buffer = String::with_capacity(1024);
    generate_declaration::<T>(&mut buffer);
    buffer.push('\n');
    Ok(buffer)
}

fn generate_declaration<T: Reflect + ?Sized + 'static>(buffer: &mut String) {

    buffer.push_str("\n\n/**\n * Generated binding.\n */\n");
    buffer.push_str(T::JSDOC_COMMENT.unwrap_or(""));
    buffer.push_str(" */\nexport ");
    buffer.push_str(&T::ts_definition());
    buffer.push_str("\n");
}