use std::{collections::HashSet, io::Write, path::PathBuf, sync::{LazyLock, Mutex}};

use crate::{Error, Reflect};

mod recursive_export;
pub(crate) use recursive_export::export_recursively;
pub(crate) use recursive_export::export_schema_recursively;

pub(crate) static EXPORTED_TYPES: LazyLock<Mutex<HashSet<String>>> = LazyLock::new(|| { Mutex::new(HashSet::new()) });
pub(crate) static EXPORTED_SCHEMAS: LazyLock<Mutex<HashSet<String>>> = LazyLock::new(|| { Mutex::new(HashSet::new()) });
pub(crate) const FILE_HEADER: &str = "/**\n * This file was generated by this project's reflection framework.\n * Don't edit it manually. \n */\n\n";

const SCHEMAS_MAP_VAR_NAME: &str = "schemas";

/// Gets the export path for types.
/// All types are currently exported into the same file.
fn get_export_file_path() -> PathBuf {
    PathBuf::from("./bindings/index.ts")
}

/// Gets the export path for schemas.
/// All schemas are currently exported into the same file.
fn get_schema_export_file_path() -> PathBuf {
    PathBuf::from("./bindings/schemas.ts")
}

pub(crate) fn export<T: Reflect + ?Sized + 'static>() -> Result<bool, Error> {
    let mut exported_types = EXPORTED_TYPES.lock().unwrap();

    // If this type has already been exported, return early
    let type_name = std::any::type_name::<T>();
    if exported_types.contains(type_name) {
        return Ok(false);
    }

    let path = get_export_file_path();

    // If the file or directory doesn't exist, create it
    if !path.exists() {
        std::fs::create_dir_all(path.parent().unwrap())?;
    }
    
    // If no types have been exported yet, delete the file if it exists
    if exported_types.is_empty() {
        if path.exists() {
            std::fs::remove_file(&path)?;
        }
        // Create the file and write the header
        std::fs::write(&path, FILE_HEADER)?;
    }

    // Append the type to the file
    let mut file = std::fs::OpenOptions::new().append(true).open(path)?;

    let buffer = export_to_string::<T>()?;
    file.write_all(buffer.as_bytes())?;

    // Add the type to the set of exported types
    exported_types.insert(std::any::type_name::<T>().to_string());

    Ok(true)
}

pub(crate) fn export_to_string<T: Reflect + ?Sized + 'static>() -> Result<String, Error> {
    let mut buffer = String::with_capacity(1024);
    generate_declaration::<T>(&mut buffer);
    buffer.push('\n');
    Ok(buffer)
}

fn generate_declaration<T: Reflect + ?Sized + 'static>(buffer: &mut String) {
    buffer.push_str("/**\n * Generated binding.\n");
    buffer.push_str(T::JSDOC_COMMENT.unwrap_or("").lines().map(|line| format!(" * {}\n", line)).collect::<String>().as_str());
    buffer.push_str(" */\nexport type ");
    buffer.push_str(&T::ts_type_name());
    buffer.push_str(" = ");
    buffer.push_str(&T::ts_definition());
    buffer.push_str(";\n");
}

pub(crate) fn export_schema<T: Reflect + ?Sized + 'static>() -> Result<bool, Error> {
    let mut exported_schemas = EXPORTED_SCHEMAS.lock().unwrap();

    // If this schema has already been exported, return early
    let type_name = std::any::type_name::<T>();
    if exported_schemas.contains(type_name) {
        return Ok(false);
    }

    let path = get_schema_export_file_path();

    // If the file or directory doesn't exist, create it
    if !path.exists() {
        std::fs::create_dir_all(path.parent().unwrap())?;
    }
    
    // If no schemas have been exported yet, delete the file if it exists
    if exported_schemas.is_empty() {
        if path.exists() {
            std::fs::remove_file(&path)?;
        }
        // Create the file and write the header
        std::fs::write(&path, FILE_HEADER)?;

        // Write our own schema bindings to a file next to the schema file
        let schema_bindings = include_str!("../bindings/index.ts");
        std::fs::write(&path.with_file_name("schema_types.ts"), schema_bindings)?;

        // Write the schema registry header and an import for the schema types
        std::fs::write(&path, format!("import type {{ Schema }} from './schema_types';

// Define the schema registry. To avoid infinite recursion, we use a object and reference
// schemas by name.
export let {}: {{ [key: string]: Schema }} = {{ /* Items set later in this file */ }};

", SCHEMAS_MAP_VAR_NAME))?;
    }

    // Append the schema to the file
    let mut file = std::fs::OpenOptions::new().append(true).open(path)?;
    
    let buffer = export_schema_to_string::<T>()?;
    file.write_all(buffer.as_bytes())?;

    // Add the schema to the set of exported schemas
    exported_schemas.insert(std::any::type_name::<T>().to_string());

    Ok(true)
}

pub(crate) fn export_schema_to_string<T: Reflect + ?Sized + 'static>() -> Result<String, Error> {
    let mut buffer = String::with_capacity(1024);
    generate_schema_declaration::<T>(&mut buffer);
    buffer.push('\n');
    Ok(buffer)
}

fn generate_schema_declaration<T: Reflect + ?Sized + 'static>(buffer: &mut String) {
    buffer.push_str("/**\n * Generated schema.\n");
    buffer.push_str(T::JSDOC_COMMENT.unwrap_or("").lines().map(|line| format!(" * {}\n", line)).collect::<String>().as_str());
    buffer.push_str(" */\nexport const ");

    let schema_variable_name = format!("{}Schema", T::ts_type_name());
    buffer.push_str(&schema_variable_name);

    buffer.push_str(": Schema = ");

    let schema = T::schema();
    let schema = serde_json::to_string_pretty(&schema).expect("could not serialize schema");
    buffer.push_str(&schema);

    buffer.push_str(format!(";\n{}[\"{}\"] = {};\n", SCHEMAS_MAP_VAR_NAME, T::ts_type_name(), schema_variable_name).as_str());
}